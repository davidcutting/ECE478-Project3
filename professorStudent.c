/*
 * professorStudent.c
 *
 *  Problem Description:
 *  You have been hired by the CIS Department to write code to help synchronize
 *  a professor and his/her students during office hours. The professor, of
 *  course, wants to take a nap if no students are around to ask questions; if
 *  there are students who want to ask questions, they must synchronize with
 *  each other and with the professor so that
 *      (i)   only one person is speaking at any one time,
 *      (ii)  each student question is answered by the professor, and
 *      (iii) no student asks another question before the professor is done
 *            answering the previous one.
 *
 *  You are to write four procedures:
 *      AnswerStart(),
 *      AnswerDone(),
 *      QuestionStart(), and
 *      QuestionDone()
 *
 *  The professor loops running the code:
 *      AnswerStart(); give answer;
 *      AnswerDone().
 *
 *  AnswerStart doesn't return until a question has been asked. Each student
 *  loops running the code:
 *      QuestionStart(); ask question;
 *      QuestionDone().
 *
 *  QuestionStart() does not return until it is the student's turn to ask a
 *  question. Since professors consider it rude for a student not to wait for an
 *  answer, QuestionDone() should not return until the professor has finished
 *  answering the question. Use semaphores for synchronization.
 */

 #include <pthread.h>
 #include <semaphore.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <iostream>
 #include <ostream>

 // 0 sem is shared between threads of the process
 // 1 sem is shared between processes
 #define SHARED 1

// function definitions
void* Professor(void* arg);
void* Student(void* arg);
void AnswerStart();
void AnswerDone();
void QuestionStart();
void QuestionDone();

int numStudents; // parameter for number of students to create
int student; // index of student thread as created in loop
sem_t speak, question, answer; // semaphores, reference readme

int main(int argc, char* argv[]) {

    // check to see if user gave appropriate arguments
    if (argc < 2) {
	    printf("Usage: professorStudent <number of students>\n");
	    exit(0);
    }
    numStudents = atoi(argv[1]); // number of students from command line params

    pthread_t prof_id, stud_id;

    // one speaker is allowed at the start
    sem_init(&speak, SHARED, 1);
    // size starts at 0, because questions are generated by students
    sem_init(&question, SHARED, 0);
    // size starts at 0, because answers are generated by the professor
    sem_init(&answer, SHARED, 0);

    // create a professor thread
    pthread_create(&prof_id, NULL, Professor, NULL);
    // loop to create numStudents of student threads
    for (student = 0; student < numStudents; student++) {
        pthread_create(&stud_id, NULL, Student, NULL);
        pthread_join(stud_id, NULL);
    }
    pthread_join(prof_id, NULL);
    pthread_exit(0);
}

// Professor thread, only to be created once
void* Professor(void* arg) {
    while(true) {
        AnswerStart();
        std::cout << "The professor is answering the question." << std::endl;
        AnswerDone();
    }
}

// Student thread, to be created numStudents times
void* Student(void* arg) {
    int studentNum = student; // Have each thread grab what number student they are
    std::cout << student << " : The student is ready to ask a question." << std::endl;
    QuestionStart();
    std::cout << studentNum << " : The student is asking a question." << std::endl;
    QuestionDone();
    std::cout << studentNum << " : The student is done asking a question." << std::endl;
}

// Wait for a question to start answering
void AnswerStart() {
    std::cout << "The professor wants to be asked a question." << std::endl;
    sem_wait(&question); // wait for a question
    sched_yield();
}

// Post that the question has been answered
void AnswerDone() {
    std::cout << "The professor is finished answering." << std::endl;
    sem_post(&answer); // post an answer
    sched_yield();
}

// Wait for a turn to speak, then post that a question has been asked
void QuestionStart() {
    sem_wait(&speak); // wait to speak
    sem_post(&question); // post a question
    sched_yield();
}

/// Wait for an answer, then post that other threads may speak
void QuestionDone() {
    sem_wait(&answer); // wait for an answer
    sem_post(&speak); // let others speak
    sched_yield();
}
